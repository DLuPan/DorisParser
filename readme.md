### 1、背景

因为需要对执行SQL进行统一管理与风险控制，所以需要对不同引擎的SQL都需要统一解析转换为我们自己的模型对象。

目前的SQL解析实现列表

| 引擎       | 解析实现      | 备注 |
| ---------- | ------------- | ---- |
| Mysql      | druid         |      |
| Hive       | druid         |      |
| Doris      | javacup+jflex |      |
| Clickhouse | Antlr4        |      |

### 2、相关实现参考

- [Doris](./parser-doris/readme.md)
- [Clickhouse](./parser-clickhouse/readme.md)


## 以下功能还在开发中，目前开发分支：v2.0.0-ast-build
### 3、待完成自定AST模型

实现自定义的AST模型，用于统一对外服务，降低学习成本，最终的目的就是不同的技术栈输出统一AST模型，而不是现在的简单聚合，多模型并存。

后续提供plugin实现自动生成通用指令集（有待思考如何实现，感觉很有意思）

### 4、待完成DorisDB Antlr4改造

目前DorisDB是直接搬运的官方源码进行阉割的，这里后续要移除官方AST模型使用自定义的AST模型来实现，所以这个也是改造的难点（后续实现）

### 4、CK解析实现

首先利用Antlr4实现sql解析功能，同时生成Antlr4通用CK-AST模型，最后利用指令模式（生成指令集）通过match-convert来实现转换，哈哈哈这里也比较有意思，为什么要通过指令，为什么不直接用visitor？

首先利用visitor是可以直接完成转换，但是会存在一个问题，如果一个visitor实现就会导致visitor功能复杂极度臃肿，多visitor实现就会导致visitor之间强依赖，职能不清晰。所以最终考虑了
使用指令模型来改造，这样的好处就是最终处理的是一个指令集，然后利用责任链来实现match-convert，而每个visitor就都是独立的，visitor之间是无任何依赖关系的。

那么数据Context如何找到对应的visitor？

首先利用责任链去匹配Context然后去执行指令，指令会绑定唯一的访问者（同时也是指令的接收者）然后执行指令动作（具体接收者执行业务动作）所以这里就又和调用者解耦了，这样的好处就是可以实现迭代开发。
开发一点调试一点发布一点，因为每个指令的实现是自由的和调用者无关哈哈哈这样整体逻辑就很清晰而且不会乱。

如果对CK解析感兴趣可以看v2.0.0-ast-build的代码

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package com.lfsenior.sqlparser.doris.analysis;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;


import com.lfsenior.sqlparser.doris.catalog.AggregateType;
import com.lfsenior.sqlparser.doris.catalog.KeysType;
import com.lfsenior.sqlparser.doris.catalog.ScalarType;
import com.lfsenior.sqlparser.doris.catalog.Type;
import com.lfsenior.sqlparser.doris.common.AnalysisException;
import com.lfsenior.sqlparser.doris.common.Version;


import com.google.common.collect.Lists;
import com.google.common.collect.Maps;

import java_cup.runtime.Symbol;

// Commented by Zhao Chun
// Now we have 2 shift/reduce conflict
// between TIMESTAMP "20100101" and TIMESTAMP "alias"
// between DATE "20100101" and DATE "alias"

parser code {:
    private Symbol errorToken;
    public boolean isVerbose = false;
    public String wild;

    // List of expected tokens ids from current parsing state for generating syntax error message
    private final List<Integer> expectedTokenIds = Lists.newArrayList();

    // To avoid reporting trivial tokens as expected tokens in error messages
    private boolean reportExpectedToken(Integer tokenId) {
        if (SqlScanner.isKeyword(tokenId) ||
                tokenId.intValue() == SqlParserSymbols.COMMA ||
                tokenId.intValue() == SqlParserSymbols.IDENT) {
            return true;
        } else {
            return false;
        }
    }

    private String getErrorTypeMessage(int lastTokenId) {
        String msg = null;
        switch(lastTokenId) {
            case SqlParserSymbols.UNMATCHED_STRING_LITERAL:
                msg = "Unmatched string literal";
                break;
            case SqlParserSymbols.NUMERIC_OVERFLOW:
                msg = "Numeric overflow";
                break;
            default:
                msg = "Syntax error";
                break;
        }
        return msg;
    }

    // Override to save error token, just update error information.
    @Override
    public void syntax_error(Symbol token) {
        errorToken = token;

        // derive expected tokens from current parsing state
        expectedTokenIds.clear();
        int state = ((Symbol)stack.peek()).parse_state;
        // get row of actions table corresponding to current parsing state
        // the row consists of pairs of <tokenId, actionId>
        // a pair is stored as row[i] (tokenId) and row[i+1] (actionId)
        // the last pair is a special error action
        short[] row = action_tab[state];
        short tokenId;
        // the expected tokens are all the symbols with a
        // corresponding action from the current parsing state
        for (int i = 0; i < row.length-2; ++i) {
            // Get tokenId and skip actionId
            tokenId = row[i++];
            expectedTokenIds.add(Integer.valueOf(tokenId));
        }
    }

    // Override to keep it from calling report_fatal_error()
    // This exception is not AnalysisException because we don't want this report to client.
    @Override
    public void unrecovered_syntax_error(Symbol cur_token) throws AnalysisException {
        throw new AnalysisException(getErrorTypeMessage(cur_token.sym));
    }


    // Manually throw a parse error on a given symbol for special circumstances.
    public void parseError(String symbolName, int symbolId) throws AnalysisException {
        Symbol errorToken = getSymbolFactory().newSymbol(symbolName, symbolId,
                ((Symbol) stack.peek()), ((Symbol) stack.peek()), null);
        // Call syntax error to gather information about expected tokens, etc.
        // syntax_error does not throw an exception
        syntax_error(errorToken);

        unrecovered_syntax_error(errorToken);
    }

    // Returns error string, consisting of the original
    // stmt with a '^' under the offending token. Assumes
    // that parse() has been called and threw an exception
    public String getErrorMsg(String stmt) {
        if (errorToken == null || stmt == null) {
            return null;
        }
        String[] lines = stmt.split("\n", -1);
        StringBuffer result = new StringBuffer();
        result.append(getErrorTypeMessage(errorToken.sym) + " in line ");
        result.append(errorToken.left);
        result.append(":\n");

        // errorToken_.left is the line number of error.
        // errorToken_.right is the column number of the error.
        // index is start from 0, so "minus 1" is the real error line idx
        String errorLine = lines[errorToken.left - 1];
        // If the error is that additional tokens are expected past the end,
        // errorToken_.right will be past the end of the string.
        int lastCharIndex = Math.min(errorLine.length(), errorToken.right);
        int maxPrintLength = 60;
        int errorLoc = 0;
        if (errorLine.length() <= maxPrintLength) {
            // The line is short. Print the entire line.
            result.append(errorLine);
            result.append('\n');
            errorLoc = errorToken.right;
        } else {
            // The line is too long. Print maxPrintLength/2 characters before the error and
            // after the error.
            int contextLength = maxPrintLength / 2 - 3;
            String leftSubStr;
            if (errorToken.right > maxPrintLength / 2) {
                leftSubStr = "..." + errorLine.substring(errorToken.right - contextLength,
                        lastCharIndex);
            } else {
                leftSubStr = errorLine.substring(0, errorToken.right);
            }
            errorLoc = leftSubStr.length();
            result.append(leftSubStr);
            if (errorLine.length() - errorToken.right > maxPrintLength / 2) {
                result.append(errorLine.substring(errorToken.right,
                            errorToken.right + contextLength) + "...");
            } else {
                result.append(errorLine.substring(lastCharIndex));
            }
            result.append("\n");
        }

        // print error indicator
        for (int i = 0; i < errorLoc - 1; ++i) {
            result.append(' ');
        }
        result.append("^\n");

        // only report encountered and expected tokens for syntax errors
        if (errorToken.sym == SqlParserSymbols.UNMATCHED_STRING_LITERAL ||
                errorToken.sym == SqlParserSymbols.NUMERIC_OVERFLOW) {
            return result.toString();
        }

        // append last encountered token
        result.append("Encountered: ");
        String lastToken = SqlScanner.tokenIdMap.get(Integer.valueOf(errorToken.sym));
        if (lastToken != null) {
            result.append(lastToken);
        } else if (SqlScanner.isKeyword((String) errorToken.value)) {
            result.append("A reserved word cannot be used as an identifier: ").append((String) errorToken.value);
        } else {
            result.append("Unknown last token with id: " + errorToken.sym);
        }

        // Append expected tokens
        result.append('\n');
        result.append("Expected: ");
        String expectedToken = null;
        Integer tokenId = null;
        for (int i = 0; i < expectedTokenIds.size(); ++i) {
            tokenId = expectedTokenIds.get(i);
            // keywords hints
            if (SqlScanner.isKeyword(lastToken) && tokenId.intValue() == SqlParserSymbols.IDENT) {
                result.append(String.format("%s is keyword, maybe `%s`", lastToken, lastToken) + ", ");
                continue;
            }

            if (reportExpectedToken(tokenId)) {
                expectedToken = SqlScanner.tokenIdMap.get(tokenId);
                result.append(expectedToken + ", ");
            }
        }
        // remove trailing ", "
        result.delete(result.length() - 2, result.length());
        result.append('\n');

        return result.toString();
    }

:};

// Total keywords of doris
terminal String KW_ADD, KW_ADMIN, KW_AFTER, KW_AGGREGATE, KW_ALL, KW_ALTER, KW_AND, KW_ANTI, KW_APPEND, KW_AS, KW_ASC, KW_AUTHORS,
    KW_BACKEND, KW_BACKUP, KW_BETWEEN, KW_BEGIN, KW_BIGINT, KW_BITMAP, KW_BITMAP_UNION, KW_BOOLEAN,  KW_BROKER, KW_BACKENDS, KW_BY, KW_BUILTIN,
    KW_CANCEL, KW_CASE, KW_CAST, KW_CHAIN, KW_CHAR, KW_CHARSET, KW_CHECK, KW_CLUSTER, KW_CLUSTERS,
    KW_COLLATE, KW_COLLATION, KW_COLUMN, KW_COLUMNS, KW_COMMENT, KW_COMMIT, KW_COMMITTED,
    KW_CONFIG, KW_CONNECTION, KW_CONNECTION_ID, KW_CONSISTENT, KW_CONVERT, KW_COUNT, KW_CREATE, KW_CROSS, KW_CUBE, KW_CURRENT, KW_CURRENT_USER,
    KW_DATA, KW_DATABASE, KW_DATABASES, KW_DATE, KW_DATETIME, KW_DAY, KW_DECIMAL, KW_DECOMMISSION, KW_DEFAULT, KW_DESC, KW_DESCRIBE,
    KW_DELETE, KW_DISTINCT, KW_DISTINCTPC, KW_DISTINCTPCSA, KW_DISTRIBUTED, KW_DISTRIBUTION, KW_DYNAMIC, KW_BUCKETS, KW_DIV, KW_DOUBLE, KW_DROP, KW_DROPP, KW_DUPLICATE,
    KW_ELSE, KW_ENABLE, KW_END, KW_ENGINE, KW_ENGINES, KW_ENTER, KW_ERRORS, KW_EVENTS, KW_EXCEPT, KW_EXCLUDE,
    KW_EXISTS, KW_EXPORT, KW_EXTERNAL, KW_EXTRACT,
    KW_FALSE, KW_FEATURE, KW_FOLLOWER, KW_FOLLOWING, KW_FREE, KW_FROM, KW_FILE, KW_FILTER, KW_FIRST, KW_FLOAT, KW_FOR, KW_FORCE, KW_FORMAT, KW_FRONTEND, KW_FRONTENDS, KW_FULL, KW_FUNCTION, KW_FUNCTIONS,
    KW_GLOBAL, KW_GRANT, KW_GRANTS, KW_GROUP, KW_GROUPING,
    KW_HASH, KW_HAVING, KW_HDFS, KW_HELP,KW_HLL, KW_HLL_UNION, KW_HOUR, KW_HUB,
    KW_IDENTIFIED, KW_IF, KW_IN, KW_INDEX, KW_INDEXES, KW_INFILE, KW_INSTALL,
    KW_INNER, KW_INSERT, KW_INT, KW_INTERMEDIATE, KW_INTERSECT, KW_INTERVAL, KW_INTO, KW_IS, KW_ISNULL, KW_ISOLATION,
    KW_JOIN,
    KW_KEY, KW_KEYS, KW_KILL,
    KW_LABEL, KW_LARGEINT, KW_LAST, KW_LEFT, KW_LESS, KW_LEVEL, KW_LIKE, KW_LIMIT, KW_LINK, KW_LOAD,
    KW_LOCAL, KW_LOCATION,
    KW_MATERIALIZED, KW_MAX, KW_MAX_VALUE, KW_MERGE, KW_MIN, KW_MINUTE, KW_MINUS, KW_MIGRATE, KW_MIGRATIONS, KW_MODIFY, KW_MONTH,
    KW_NAME, KW_NAMES, KW_NEGATIVE, KW_NO, KW_NOT, KW_NULL, KW_NULLS,
    KW_OBSERVER, KW_OFFSET, KW_ON, KW_ONLY, KW_OPEN, KW_OR, KW_ORDER, KW_OUTER, KW_OUTFILE, KW_OVER,
    KW_PARTITION, KW_PARTITIONS, KW_PASSWORD, KW_PATH, KW_PAUSE, KW_PIPE, KW_PRECEDING,
    KW_PLUGIN, KW_PLUGINS,
    KW_PROC, KW_PROCEDURE, KW_PROCESSLIST, KW_PROPERTIES, KW_PROPERTY,
    KW_QUERY, KW_QUOTA,
    KW_RANDOM, KW_RANGE, KW_READ, KW_RECOVER, KW_REGEXP, KW_RELEASE, KW_RENAME,
    KW_REPAIR, KW_REPEATABLE, KW_REPOSITORY, KW_REPOSITORIES, KW_REPLACE, KW_REPLACE_IF_NOT_NULL, KW_REPLICA, KW_RESOURCE, KW_RESOURCES, KW_RESTORE, KW_RETURNS, KW_RESUME, KW_REVOKE,
    KW_RIGHT, KW_ROLE, KW_ROLES, KW_ROLLBACK, KW_ROLLUP, KW_ROUTINE, KW_ROW, KW_ROWS,
    KW_S3, KW_SCHEMA, KW_SCHEMAS, KW_SECOND, KW_SELECT, KW_SEMI, KW_SERIALIZABLE, KW_SESSION, KW_SET, KW_SETS, KW_SET_VAR, KW_SHOW, KW_SIGNED,
    KW_SMALLINT, KW_SNAPSHOT, KW_SONAME, KW_SPLIT, KW_START, KW_STATUS, KW_STOP, KW_STORAGE, KW_STRING,
    KW_SUM, KW_SUPERUSER, KW_SYNC, KW_SYSTEM,
    KW_TABLE, KW_TABLES, KW_TABLET, KW_TASK, KW_TEMPORARY, KW_TERMINATED, KW_THAN, KW_TIME, KW_THEN, KW_TIMESTAMP, KW_TINYINT,
    KW_TO, KW_TRANSACTION, KW_TRIGGERS, KW_TRIM, KW_TRUE, KW_TRUNCATE, KW_TYPE, KW_TYPES,
    KW_UNCOMMITTED, KW_UNBOUNDED, KW_UNION, KW_UNIQUE, KW_UNSIGNED, KW_USE, KW_USER, KW_USING, KW_UNINSTALL,
    KW_VALUE, KW_VALUES, KW_VARCHAR, KW_VARIABLES, KW_VERBOSE, KW_VIEW,
    KW_WARNINGS, KW_WEEK, KW_WHEN, KW_WHITELIST, KW_WHERE, KW_WITH, KW_WORK, KW_WRITE,
    KW_YEAR;

terminal COMMA, DOT, DOTDOTDOT, AT, STAR, LPAREN, RPAREN, SEMICOLON, LBRACKET, RBRACKET, DIVIDE, MOD, ADD, SUBTRACT;
terminal BITAND, BITOR, BITXOR, BITNOT;
terminal EQUAL, NOT, LESSTHAN, GREATERTHAN, SET_VAR;
terminal COMMENTED_PLAN_HINT_START, COMMENTED_PLAN_HINT_END;
terminal String IDENT;
terminal String NUMERIC_OVERFLOW;
terminal Long INTEGER_LITERAL;
terminal String LARGE_INTEGER_LITERAL;
terminal Double FLOATINGPOINT_LITERAL;
terminal BigDecimal DECIMAL_LITERAL;
terminal String STRING_LITERAL;
terminal String UNMATCHED_STRING_LITERAL;
terminal String COMMENTED_PLAN_HINTS;

// Statement that the result of this parser.
nonterminal List<StatementBase> stmts;
nonterminal StatementBase stmt,
    create_stmt,alter_stmt;



nonterminal ArrayList<String> ident_list;

nonterminal TableName table_name;

nonterminal TypeDef type_def;

nonterminal Type type;


nonterminal Map<String, String> key_value_map, opt_key_value_map, opt_properties, opt_ext_properties,opt_enable_feature_properties;
nonterminal ColumnDef column_definition;
nonterminal IndexDef index_definition;
nonterminal ArrayList<ColumnDef> column_definition_list;
nonterminal ArrayList<IndexDef> index_definition_list;
nonterminal AggregateType opt_agg_type;
nonterminal PartitionDesc opt_partition;
nonterminal DistributionDesc opt_distribution;
nonterminal Integer opt_distribution_number;
nonterminal Long opt_field_length;
nonterminal KeysDesc opt_keys;
nonterminal PartitionNames opt_partition_names, partition_names;

nonterminal PartitionKeyDesc partition_key_desc;
nonterminal PartitionKeyDesc fixed_partition_key_desc;
nonterminal List<PartitionValue> partition_key_list;
nonterminal SingleRangePartitionDesc single_range_partition_desc;
nonterminal List<SingleRangePartitionDesc> opt_single_range_partition_desc_list;
nonterminal List<SingleRangePartitionDesc> single_range_partition_desc_list;



nonterminal List<String> opt_dup_keys;
nonterminal List<String> string_list;



// Boolean
nonterminal Boolean  opt_is_allow_null, opt_is_key;
nonterminal String opt_from_rollup,opt_to_rollup;
nonterminal ColumnPosition opt_col_pos;

nonterminal Boolean opt_tmp;

// Alter statement
nonterminal AlterClause alter_table_clause;
nonterminal List<AlterClause>  alter_table_clause_list,opt_rollup, add_rollup_clause_list,drop_rollup_clause_list;
nonterminal AddRollupClause add_rollup_clause;



//
nonterminal String keyword, ident,
        time_unit;

nonterminal String opt_comment, opt_engine;
nonterminal ColumnDef.DefaultValue opt_default_value;
nonterminal Boolean opt_if_not_exists,opt_if_exists;
nonterminal Boolean opt_external;
nonterminal Boolean opt_force;

nonterminal IndexDef.IndexType opt_index_type;



nonterminal Boolean opt_signed_unsigned;

precedence nonassoc COMMA;
precedence nonassoc STRING_LITERAL;
precedence nonassoc KW_COLUMNS;
precedence nonassoc KW_WITH;

precedence left KW_FULL, KW_MERGE;
precedence left DOT;
precedence left SET_VAR;
precedence left KW_OR;
precedence left KW_AND;
precedence left KW_NOT, NOT;
precedence left KW_BETWEEN, KW_IN, KW_IS, KW_EXISTS;
precedence left KW_LIKE, KW_REGEXP;
precedence left EQUAL, LESSTHAN, GREATERTHAN;
precedence left ADD, SUBTRACT;
precedence left AT, STAR, DIVIDE, MOD, KW_DIV;
precedence left BITAND, BITOR, BITXOR;
precedence left KW_PIPE;
precedence left BITNOT;
precedence left KW_ORDER, KW_BY, KW_LIMIT;
precedence right KW_PROPERTIES;
precedence left LPAREN, RPAREN;
// Support chaining of timestamp arithmetic exprs.
precedence left KW_INTERVAL;
precedence left KW_OVER;
precedence left KW_COLLATE;
precedence left KW_PARTITION;
precedence left KW_PARTITIONS;
precedence right KW_TEMPORARY;
precedence right LBRACKET;


start with stmts;

stmts ::=
    stmt:stmt
    {:
        RESULT = Lists.newArrayList(stmt);
    :}
    | stmts:stmts SEMICOLON stmt:stmt
    {:
        stmts.add(stmt);
        RESULT = stmts;
    :}
    ;



stmt ::=
    alter_stmt:stmt
     {: RESULT = stmt; :}
    | create_stmt:query
     {: RESULT = query; :}
    | /* empty: query only has comments */
    {:
         RESULT = new EmptyStmt();
    :}
    ;



add_rollup_clause ::=
    ident:rollupName LPAREN ident_list:cols RPAREN opt_dup_keys:dup_keys opt_from_rollup:baseRollup opt_properties:properties
    {:
        RESULT = new AddRollupClause(rollupName, cols, dup_keys, baseRollup, properties);
    :}
    ;

add_rollup_clause_list ::=
    add_rollup_clause:clause
    {:
        RESULT = Lists.newArrayList(clause);
    :}
    | add_rollup_clause_list:list COMMA add_rollup_clause:clause
    {:
        list.add(clause);
        RESULT = list;
    :}
    ;

opt_to_rollup ::=
    {:
        RESULT = null;
    :}
    | KW_TO ident:rollup
    {:
        RESULT = rollup;
    :}
    | KW_IN ident:rollup
    {:
        RESULT = rollup;
    :}
    ;

opt_from_rollup ::=
    {:
        RESULT = null;
    :}
    | KW_FROM ident:rollup
    {:
        RESULT = rollup;
    :}
    ;

opt_col_pos ::=
    {:
        RESULT = null;
    :}
    | KW_FIRST
    {:
        RESULT = ColumnPosition.FIRST;
    :}
    | KW_AFTER ident:col
    {:
        RESULT = new ColumnPosition(col);
    :}
    ;

opt_dup_keys ::=
    {:
        RESULT = null;
    :}
    | KW_DUPLICATE KW_KEY LPAREN ident_list:cols RPAREN
    {:
        RESULT = cols;
    :}
    ;







// Create Statement
create_stmt ::=
    /* Table */
    KW_CREATE opt_external:isExternal KW_TABLE opt_if_not_exists:ifNotExists table_name:name KW_LIKE table_name:existed_name
    {:
        RESULT = new CreateTableLikeStmt(ifNotExists, name, existed_name);
    :}
    | KW_CREATE opt_external:isExternal KW_TABLE opt_if_not_exists:ifNotExists table_name:name
            LPAREN column_definition_list:columns RPAREN opt_engine:engineName
            opt_keys:keys
            opt_comment:tableComment
            opt_partition:partition
            opt_distribution:distribution
            opt_rollup:index
            opt_properties:tblProperties
            opt_ext_properties:extProperties
    {:
        RESULT = new CreateTableStmt(ifNotExists, isExternal, name, columns, engineName, keys, partition,
        distribution, tblProperties, extProperties, tableComment, index);
    :}
    | KW_CREATE opt_external:isExternal KW_TABLE opt_if_not_exists:ifNotExists table_name:name
            LPAREN column_definition_list:columns COMMA index_definition_list:indexes RPAREN opt_engine:engineName
            opt_keys:keys
            opt_comment:tableComment
            opt_partition:partition
            opt_distribution:distribution
            opt_rollup:index
            opt_properties:tblProperties
            opt_ext_properties:extProperties
    {:
        RESULT = new CreateTableStmt(ifNotExists, isExternal, name, columns, indexes, engineName, keys, partition,
        distribution, tblProperties, extProperties, tableComment, index);
    :}
    ;

// Alter Statement
alter_stmt ::=
    KW_ALTER KW_TABLE table_name:tbl
    alter_table_clause_list:clauses
    {:
        RESULT = new AlterTableStmt(tbl, clauses);
    :}
    | KW_ALTER KW_TABLE table_name:tbl KW_ADD KW_ROLLUP add_rollup_clause_list:clauses
    {:
        RESULT = new AlterTableStmt(tbl, clauses);
    :}
    | KW_ALTER KW_TABLE table_name:tbl KW_DROP KW_ROLLUP drop_rollup_clause_list:clauses
    {:
        RESULT = new AlterTableStmt(tbl, clauses);
    :}
    ;


alter_table_clause_list ::=
    alter_table_clause:clause
    {:
        RESULT = Lists.newArrayList(clause);
    :}
    | alter_table_clause_list:list COMMA alter_table_clause:clause
    {:
        list.add(clause);
        RESULT = list;
    :}
    ;

alter_table_clause ::=
    KW_ADD KW_COLUMN column_definition:col opt_col_pos:col_pos opt_to_rollup:rollup opt_properties:properties
    {:
        RESULT = new AddColumnClause(col, col_pos, rollup, properties);
    :}
    | KW_ADD KW_COLUMN LPAREN column_definition_list:cols RPAREN opt_to_rollup:rollup opt_properties:properties
    {:
        RESULT = new AddColumnsClause(cols, rollup, properties);
    :}
    | KW_DROP KW_COLUMN ident:col opt_from_rollup:rollup opt_properties:properties
    {:
        RESULT = new DropColumnClause(col, rollup, properties);
    :}
    | KW_MODIFY KW_COLUMN column_definition:col opt_col_pos:col_pos opt_from_rollup:rollup opt_properties:properties
    {:
        RESULT = new ModifyColumnClause(col, col_pos, rollup, properties);
    :}
    | KW_ORDER KW_BY LPAREN ident_list:cols RPAREN opt_from_rollup:rollup opt_properties:properties
    {:
        RESULT = new ReorderColumnsClause(cols, rollup, properties);
    :}
    | KW_SET LPAREN key_value_map:properties RPAREN
    {:
        RESULT = new ModifyTablePropertiesClause(properties);
    :}
    | KW_ADD opt_tmp:isTempPartition single_range_partition_desc:desc opt_distribution:distribution opt_properties:properties
    {:
        RESULT = new AddPartitionClause(desc, distribution, properties, isTempPartition);
    :}
    | KW_DROP opt_tmp:isTempPartition KW_PARTITION opt_if_exists:ifExists ident:partitionName opt_force:force
    {:
        RESULT = new DropPartitionClause(ifExists, partitionName, isTempPartition, force ? force : isTempPartition);
    :}
    | KW_MODIFY KW_PARTITION ident:partitionName KW_SET LPAREN key_value_map:properties RPAREN
    {:
        ArrayList<String> partitions = new ArrayList<String>();
        partitions.add(partitionName);
        RESULT = new ModifyPartitionClause(partitions, properties);
    :}
    | KW_MODIFY KW_PARTITION LPAREN ident_list:partitions RPAREN KW_SET LPAREN key_value_map:properties RPAREN
    {:
        RESULT = new ModifyPartitionClause(partitions, properties);
    :}
    | KW_MODIFY KW_PARTITION LPAREN STAR RPAREN KW_SET LPAREN key_value_map:properties RPAREN
    {:
        RESULT = ModifyPartitionClause.createStarClause(properties);
    :}
    | KW_REPLACE opt_partition_names:partitions KW_WITH opt_partition_names:tempPartitions opt_properties:properties
    {:
        RESULT = new ReplacePartitionClause(partitions, tempPartitions, properties);
    :}
    | KW_REPLACE KW_WITH KW_TABLE ident:tblName opt_properties:properties
    {:
        RESULT = new ReplaceTableClause(tblName, properties);
    :}
    | KW_RENAME ident:newTableName
    {:
        RESULT = new TableRenameClause(newTableName);
    :}
    | KW_RENAME KW_ROLLUP ident:rollupName ident:newRollupName
    {:
        RESULT = new RollupRenameClause(rollupName, newRollupName);
    :}
    | KW_RENAME KW_PARTITION ident:partitionName ident:newPartitionName
    {:
        RESULT = new PartitionRenameClause(partitionName, newPartitionName);
    :}
    | KW_RENAME KW_COLUMN ident:colName ident:newColName
    {:
        RESULT = new ColumnRenameClause(colName, newColName);
    :}
    | KW_ADD index_definition:indexDef
    {:
        RESULT = new CreateIndexClause(null, indexDef, true);
    :}
    | KW_DROP KW_INDEX ident:indexName
    {:
        RESULT = new DropIndexClause(indexName, null, true);
    :}
    | KW_ENABLE KW_FEATURE STRING_LITERAL:featureName opt_enable_feature_properties:properties
    {:
        RESULT = new EnableFeatureClause(featureName, properties);
    :}
    ;

opt_enable_feature_properties ::=
    {:
    RESULT = null;
    :}
    | KW_WITH KW_PROPERTIES LPAREN key_value_map:map RPAREN
    {:
    RESULT = map;
    :}
    ;






opt_agg_type ::=
    /* not set */
    {: RESULT = null; :}
    | KW_SUM
    {:
    RESULT = AggregateType.SUM;
    :}
    | KW_MAX
    {:
    RESULT = AggregateType.MAX;
    :}
    | KW_MIN
    {:
    RESULT = AggregateType.MIN;
    :}
    | KW_REPLACE
    {:
    RESULT = AggregateType.REPLACE;
    :}
    | KW_REPLACE_IF_NOT_NULL
    {:
    RESULT = AggregateType.REPLACE_IF_NOT_NULL;
    :}
    | KW_HLL_UNION
    {:
    RESULT = AggregateType.HLL_UNION;
    :}
    | KW_BITMAP_UNION
    {:
    RESULT = AggregateType.BITMAP_UNION;
    :}
    ;

opt_partition ::=
    /* Empty: no partition */
    {:
        RESULT = null;
    :}
    /* Range partition */
    | KW_PARTITION KW_BY KW_RANGE LPAREN ident_list:columns RPAREN
            LPAREN opt_single_range_partition_desc_list:list RPAREN
    {:
        RESULT = new RangePartitionDesc(columns, list);
    :}
    ;

opt_tmp ::=
    /* empty */
    {:
        RESULT = false;
    :}
    | KW_TEMPORARY
    {:
        RESULT = true;
    :}
    ;

opt_if_exists ::=
    {:
        RESULT = false;
    :}
    | KW_IF KW_EXISTS
    {:
        RESULT = true;
    :}
    ;

opt_force ::=
     /* empty */
    {:
        RESULT = false;
    :}
    | KW_FORCE
    {:
        RESULT = true;
    :}
    ;

opt_partition_names ::=
    /* empty */
    {:
        RESULT = null;
    :}
    | partition_names:partitionNames
    {:
        RESULT = partitionNames;
    :}
    ;

partition_names ::=
    KW_PARTITION LPAREN ident_list:partitions RPAREN
    {:
        RESULT = new PartitionNames(false, partitions);
    :}
    | KW_TEMPORARY KW_PARTITION LPAREN ident_list:partitions RPAREN
    {:
        RESULT = new PartitionNames(true, partitions);
    :}
    | KW_PARTITIONS LPAREN ident_list:partitions RPAREN
    {:
        RESULT = new PartitionNames(false, partitions);
    :}
    | KW_TEMPORARY KW_PARTITIONS LPAREN ident_list:partitions RPAREN
    {:
        RESULT = new PartitionNames(true, partitions);
    :}
    | KW_PARTITION ident:partName
    {:
        RESULT = new PartitionNames(false, Lists.newArrayList(partName));
    :}
    | KW_TEMPORARY KW_PARTITION ident:partName
    {:
        RESULT = new PartitionNames(true, Lists.newArrayList(partName));
    :}
    ;

opt_distribution ::=
    /* Empty: no distributed */
    {:
        RESULT = null;
    :}
    /* Hash distributed */
    | KW_DISTRIBUTED KW_BY KW_HASH LPAREN ident_list:columns RPAREN opt_distribution_number:numDistribution
    {:
        RESULT = new HashDistributionDesc(numDistribution, columns);
    :}
    /* Random distributed */
    | KW_DISTRIBUTED KW_BY KW_RANDOM opt_distribution_number:numDistribution
    {:
        RESULT = new RandomDistributionDesc(numDistribution);
    :}
    ;

opt_rollup ::=
    /* Empty: no rollup */
    {:
        RESULT = new ArrayList<>();
    :}
    | KW_ROLLUP LPAREN add_rollup_clause_list:list RPAREN
    {:
        RESULT = list;
    :}
    ;

opt_distribution_number ::=
    /* Empty */
    {:
        /* If distribution number is null, default distribution number is 10. */
        RESULT = 10;
    :}
    | KW_BUCKETS INTEGER_LITERAL:numDistribution
    {:
        RESULT = numDistribution.intValue();
    :}
    ;

opt_keys ::=
    /* Empty */
    {:
        RESULT = null;
    :}
    /* primary_keys */
    // | KW_PRIMARY KW_KEY LPAREN ident_list:keys RPAREN
    // {:
    //     RESULT = new KeysDesc(KeysType.PRIMARY_KEYS, keys);
    // :}
    /* dup_keys */
    | KW_DUPLICATE KW_KEY LPAREN ident_list:keys RPAREN
    {:
        RESULT = new KeysDesc(KeysType.DUP_KEYS, keys);
    :}
    /* unique_keys */
    | KW_UNIQUE KW_KEY LPAREN ident_list:keys RPAREN
    {:
        RESULT = new KeysDesc(KeysType.UNIQUE_KEYS, keys);
    :}
    /* agg_keys */
    | KW_AGGREGATE KW_KEY LPAREN ident_list:keys RPAREN
    {:
        RESULT = new KeysDesc(KeysType.AGG_KEYS, keys);
    :}
    ;

opt_single_range_partition_desc_list ::=
    /* Empty */
    {:
        RESULT = null;
    :}
    | single_range_partition_desc_list:list
    {:
        RESULT = list;
    :}
    ;

single_range_partition_desc_list ::=
    single_range_partition_desc_list:list COMMA single_range_partition_desc:desc
    {:
        list.add(desc);
        RESULT = list;
    :}
    | single_range_partition_desc:desc
    {:
        RESULT = Lists.newArrayList(desc);
    :}
    ;

single_range_partition_desc ::=
    KW_PARTITION opt_if_not_exists:ifNotExists ident:partName KW_VALUES KW_LESS KW_THAN partition_key_desc:desc
        opt_key_value_map:properties
    {:
        RESULT = new SingleRangePartitionDesc(ifNotExists, partName, desc, properties);
    :}
    | KW_PARTITION opt_if_not_exists:ifNotExists ident:partName KW_VALUES fixed_partition_key_desc:desc
        opt_key_value_map:properties
    {:
        RESULT = new SingleRangePartitionDesc(ifNotExists, partName, desc, properties);
    :}
    ;

partition_key_desc ::=
    KW_MAX_VALUE
    {:
        RESULT = PartitionKeyDesc.createMaxKeyDesc();
    :}
    | LPAREN partition_key_list:keys RPAREN
    {:
        RESULT = new PartitionKeyDesc(keys);
    :}
    ;

partition_key_list ::=
    /* empty */
    {:
        List<PartitionValue> l = new ArrayList<PartitionValue>();
        RESULT = l;
    :}
    | partition_key_list:l COMMA STRING_LITERAL:item
    {:
        l.add(new PartitionValue(item));
        RESULT = l;
    :}
    | partition_key_list:l COMMA KW_MAX_VALUE
    {:
        l.add(PartitionValue.MAX_VALUE);
        RESULT = l;
    :}
    | STRING_LITERAL:item
    {:
        RESULT = Lists.newArrayList(new PartitionValue(item));
    :}
    | KW_MAX_VALUE
    {:
        RESULT = Lists.newArrayList(PartitionValue.MAX_VALUE);
    :}
    ;

fixed_partition_key_desc ::=
    /* format: [(lower), (upper))*/
    LBRACKET LPAREN partition_key_list:lower RPAREN COMMA LPAREN partition_key_list:upper RPAREN RPAREN
    {:
        RESULT = new PartitionKeyDesc(lower, upper);
    :}
    ;

opt_engine ::=
    {: RESULT = null; :}
    | KW_ENGINE EQUAL ident:engineName
    {: RESULT = engineName; :}
    ;

opt_key_value_map ::=
    {:
    RESULT = Maps.newHashMap();
    :}
    | LPAREN key_value_map:map RPAREN
    {:
    RESULT = map;
    :}
    ;

key_value_map ::=
    STRING_LITERAL:name EQUAL STRING_LITERAL:value
    {:
    RESULT = Maps.newHashMap();
    RESULT.put(name, value);
    :}
    | key_value_map:map COMMA STRING_LITERAL:name EQUAL STRING_LITERAL:value
    {:
    map.put(name, value);
    RESULT = map;
    :}
    ;

opt_properties ::=
    {:
    RESULT = null;
    :}
    | KW_PROPERTIES LPAREN key_value_map:map RPAREN
    {:
    RESULT = map;
    :}
    ;

opt_ext_properties ::=
    {:
    RESULT = null;
    :}
    | KW_BROKER KW_PROPERTIES LPAREN key_value_map:map RPAREN
    {:
    RESULT = map;
    :}
    ;

column_definition_list ::=
    column_definition:column
    {:
    RESULT = Lists.newArrayList();
    RESULT.add(column);
    :}
    | column_definition_list:list COMMA column_definition:column
    {:
    list.add(column);
    RESULT = list;
    :}
    ;

index_definition_list ::=
    index_definition:index
    {:
        RESULT = Lists.newArrayList();
        RESULT.add(index);
    :}
    | index_definition_list:list COMMA index_definition:index
    {:
        list.add(index);
        RESULT = list;
    :}
    ;

opt_default_value ::=
    /* Empty */
    {:
        RESULT = ColumnDef.DefaultValue.NOT_SET;
    :}
    | KW_DEFAULT STRING_LITERAL:value
    {:
        RESULT = new ColumnDef.DefaultValue(true, value);
    :}
    | KW_DEFAULT KW_NULL
    {:
        RESULT = ColumnDef.DefaultValue.NULL_DEFAULT_VALUE;
    :}
    ;

opt_is_key ::=
    {:
        RESULT = false;
    :}
    | KW_KEY:key
    {:
        RESULT = true;
    :}
    ;

column_definition ::=
    ident:columnName type_def:typeDef opt_is_key:isKey opt_agg_type:aggType opt_is_allow_null:isAllowNull opt_default_value:defaultValue opt_comment:comment
    {:
        ColumnDef columnDef = new ColumnDef(columnName, typeDef, isKey, aggType, isAllowNull, defaultValue, comment);
        RESULT = columnDef;
    :}
    ;

index_definition ::=
    KW_INDEX ident:indexName LPAREN ident_list:cols RPAREN opt_index_type:indexType opt_comment:comment
    {:
        RESULT = new IndexDef(indexName, cols, indexType, comment);
    :}
    ;

opt_is_allow_null ::=
    {:
        RESULT = true;
    :}
    | KW_NULL
    {:
        RESULT = true;
    :}
    | KW_NOT KW_NULL
    {:
        RESULT = false;
    :}
    ;

opt_comment ::=
    /* empty */
    {:
        RESULT = "";
    :}
    | KW_COMMENT STRING_LITERAL:comment
    {:
        RESULT = comment;
    :}
    ;

opt_index_type ::=
    {:
        RESULT = null;
    :}
    | KW_USING KW_BITMAP
    {:
        RESULT = IndexDef.IndexType.BITMAP;
    :}
    ;


opt_if_not_exists ::=
    {:
        RESULT = false;
    :}
    | KW_IF KW_NOT KW_EXISTS
    {:
        RESULT = true;
    :}
    ;

opt_external ::=
    /* empty */
    {:
        RESULT = false;
    :}
    | KW_EXTERNAL
    {:
        RESULT = true;
    :}
    ;




table_name ::=
    ident:tbl
    {: RESULT = new TableName(null, tbl); :}
    | ident:db DOT ident:tbl
    {: RESULT = new TableName(db, tbl); :}
    ;




ident_list ::=
    ident:ident
    {:
      ArrayList<String> list = new ArrayList<String>();
      list.add(ident);
      RESULT = list;
    :}
    | ident_list:list COMMA ident:ident
    {:
      list.add(ident);
      RESULT = list;
    :}
    ;


type ::=
  KW_TINYINT opt_field_length
  {: RESULT = Type.TINYINT; :}
  | KW_SMALLINT opt_field_length
  {: RESULT = Type.SMALLINT; :}
  | opt_signed_unsigned KW_INT opt_field_length
  {: RESULT = Type.INT; :}
  | KW_BIGINT opt_field_length
  {: RESULT = Type.BIGINT; :}
  | KW_LARGEINT opt_field_length
  {: RESULT = Type.LARGEINT; :}
  | KW_BOOLEAN
  {: RESULT = Type.BOOLEAN; :}
  | KW_FLOAT
  {: RESULT = Type.FLOAT; :}
  | KW_DOUBLE
  {: RESULT = Type.DOUBLE; :}
  | KW_DATE
  {: RESULT = Type.DATE; :}
  | KW_DATETIME
  {: RESULT = Type.DATETIME; :}
  | KW_TIME
  {: RESULT = Type.TIME; :}
  | KW_BITMAP
  {: RESULT = Type.BITMAP; :}
  | KW_STRING
  {: RESULT = ScalarType.createVarcharType(-1); :}
  | KW_VARCHAR LPAREN INTEGER_LITERAL:len RPAREN
  {: ScalarType type = ScalarType.createVarcharType(len.intValue());
     type.setAssignedStrLenInColDefinition();
     RESULT = type;
  :}
  | KW_VARCHAR
  {: RESULT = ScalarType.createVarcharType(-1); :}
  | KW_CHAR LPAREN INTEGER_LITERAL:len RPAREN
  {: ScalarType type = ScalarType.createCharType(len.intValue());
     type.setAssignedStrLenInColDefinition();
     RESULT = type;
  :}
  | KW_CHAR
  {: RESULT = ScalarType.createCharType(-1); :}
  | KW_DECIMAL LPAREN INTEGER_LITERAL:precision RPAREN
  {: RESULT = ScalarType.createDecimalV2Type(precision.intValue()); :}
  | KW_DECIMAL LPAREN INTEGER_LITERAL:precision COMMA INTEGER_LITERAL:scale RPAREN
  {: RESULT = ScalarType.createDecimalV2Type(precision.intValue(), scale.intValue()); :}
  | KW_DECIMAL
  {: RESULT = ScalarType.createDecimalV2Type(); :}
  | KW_HLL
  {: ScalarType type = ScalarType.createHllType();
     type.setAssignedStrLenInColDefinition();
     RESULT = type;
  :}
  ;

opt_field_length ::=
  LPAREN INTEGER_LITERAL:length RPAREN
  {: RESULT = length; :}
  |
  {: RESULT = null; :}
  ;

// signed and unsigned is meaningless for Doris.
// This is just for MySQL compatibility now.
opt_signed_unsigned ::=
  /* empty */
  {: RESULT = true; :}
  | KW_SIGNED
  {: RESULT = true; :}
  | KW_UNSIGNED
  {: RESULT = false; :}
  ;

type_def ::=
  type:t
  {: RESULT = new TypeDef(t); :}
  ;



// Keyword that we allow for identifiers
keyword ::=
    KW_AFTER:id
    {: RESULT = id; :}
    | KW_AGGREGATE:id
    {: RESULT = id; :}
    | KW_AUTHORS:id
    {: RESULT = id; :}
    | KW_BACKUP:id
    {: RESULT = id; :}
    | KW_BEGIN:id
    {: RESULT = id; :}
    | KW_BITMAP:id
    {: RESULT = id; :}
    | KW_BITMAP_UNION:id
    {: RESULT = id; :}
    | KW_BOOLEAN:id
    {: RESULT = id; :}
    | KW_BROKER:id
    {: RESULT = id; :}
    | KW_S3:id
    {: RESULT = id; :}
    | KW_HDFS:id
    {: RESULT = id; :}
    | KW_BACKENDS:id
    {: RESULT = id; :}
    | KW_BUILTIN:id
    {: RESULT = id; :}
    | KW_CHAIN:id
    {: RESULT = id; :}
    | KW_CHARSET:id
    {: RESULT = id; :}
    | KW_CHECK:id
    {: RESULT = id; :}
    | KW_COLUMNS:id
    {: RESULT = id; :}
    | KW_COMMENT:id
    {: RESULT = id; :}
    | KW_COMMITTED:id
    {: RESULT = id; :}
    | KW_CONSISTENT:id
    {: RESULT = id; :}
    | KW_COLLATION:id
    {: RESULT = id; :}
    | KW_COMMIT:id
    {: RESULT = id; :}
    | KW_CONFIG:id
    {: RESULT = id; :}
    | KW_CONNECTION:id
    {: RESULT = id; :}
    | KW_CONNECTION_ID:id
    {: RESULT = id; :}
    | KW_CONVERT:id
    {: RESULT = id; :}
    | KW_DATA:id
    {: RESULT = id; :}
    | KW_DATE:id
    {: RESULT = id; :}
    | KW_DATETIME:id
    {: RESULT = id; :}
    | KW_DISTINCTPC:id
    {: RESULT = id; :}
    | KW_DISTINCTPCSA:id
    {: RESULT = id; :}
    | KW_BUCKETS:id
    {: RESULT = id; :}
    | KW_FILE:id
    {: RESULT = id; :}
    | KW_FILTER:id
    {: RESULT = id; :}
    | KW_FIRST:id
    {: RESULT = id; :}
    | KW_FORMAT:id
    {: RESULT = id; :}
    | KW_HLL_UNION:id
    {: RESULT = id; :}
    | KW_PATH:id
    {: RESULT = id; :}
    | KW_FUNCTION:id
    {: RESULT = id; :}
    | KW_END:id
    {: RESULT = id; :}
    | KW_ENGINE:id
    {: RESULT = id; :}
    | KW_ENGINES:id
    {: RESULT = id; :}
    | KW_ERRORS:id
    {: RESULT = id; :}
    | KW_EXCLUDE:id
    {: RESULT = id; :}
    | KW_EVENTS:id
    {: RESULT = id; :}
    | KW_EXTERNAL:id
    {: RESULT = id; :}
    | KW_GLOBAL:id
    {: RESULT = id; :}
    | KW_HASH:id
    {: RESULT = id; :}
    | KW_HELP:id
    {: RESULT = id; :}
    | KW_HUB:id
    {: RESULT = id; :}
    | KW_IDENTIFIED:id
    {: RESULT = id; :}
    | KW_INDEXES:id
    {: RESULT = id; :}
    | KW_ISNULL:id
    {: RESULT = id; :}
    | KW_ISOLATION:id
    {: RESULT = id; :}
    | KW_LABEL:id
    {: RESULT = id; :}
    | KW_LAST:id
    {: RESULT = id; :}
    | KW_LESS:id
    {: RESULT = id; :}
    | KW_LEVEL:id
    {: RESULT = id; :}
    | KW_LOCAL:id
    {: RESULT = id; :}
    | KW_LOCATION:id
    {: RESULT = id; :}
    | KW_MATERIALIZED:id
    {: RESULT = id; :}
    | KW_MERGE:id
    {: RESULT = id; :}
    | KW_MODIFY:id
    {: RESULT = id; :}
    | KW_NAME:id
    {: RESULT = id; :}
    | KW_NAMES:id
    {: RESULT = id; :}
    | KW_NEGATIVE:id
    {: RESULT = id; :}
    | KW_NO:id
    {: RESULT = id; :}
    | KW_NULLS:id
    {: RESULT = id; :}
    | KW_OFFSET:id
    {: RESULT = id; :}
    | KW_ONLY:id
    {: RESULT = id; :}
    | KW_OPEN:id
    {: RESULT = id; :}
    | KW_PARTITIONS:id
    {: RESULT = id; :}
    | KW_PASSWORD:id
    {: RESULT = id; :}
    | KW_PLUGIN:id
    {: RESULT = id; :}
    | KW_PLUGINS:id
    {: RESULT = id; :}
    | KW_PROC:id
    {: RESULT = id; :}
    | KW_PROCESSLIST:id
    {: RESULT = id; :}
    | KW_PROPERTIES:id
    {: RESULT = id; :}
    | KW_PROPERTY:id
    {: RESULT = id; :}
    | KW_QUERY:id
    {: RESULT = id; :}
    | KW_QUOTA:id
    {: RESULT = id; :}
    | KW_RANDOM:id
    {: RESULT = id; :}
    | KW_RECOVER:id
    {: RESULT = id; :}
    | KW_REPEATABLE:id
    {: RESULT = id; :}
    | KW_REPLACE:id
    {: RESULT = id; :}
    | KW_REPLACE_IF_NOT_NULL:id
    {: RESULT = id; :}
    | KW_REPOSITORY:id
    {: RESULT = id; :}
    | KW_REPOSITORIES:id
    {: RESULT = id; :}
    | KW_RESOURCE:id
    {: RESULT = id; :}
    | KW_RESOURCES:id
    {: RESULT = id; :}
    | KW_RESTORE:id
    {: RESULT = id; :}
    | KW_RETURNS:id
    {: RESULT = id; :}
    | KW_ROLLBACK:id
    {: RESULT = id; :}
    | KW_ROLLUP:id
    {: RESULT = id; :}
    | KW_SCHEMA:id
    {: RESULT = id; :}
    | KW_SERIALIZABLE:id
    {: RESULT = id; :}
    | KW_SESSION:id
    {: RESULT = id; :}
    | KW_SNAPSHOT:id
    {: RESULT = id; :}
    | KW_SONAME:id
    {: RESULT = id; :}
    | KW_SPLIT:id
    {: RESULT = id; :}
    | KW_START:id
    {: RESULT = id; :}
    | KW_STATUS:id
    {: RESULT = id; :}
    | KW_STORAGE:id
    {: RESULT = id; :}
    | KW_STRING:id
    {: RESULT = id; :}
    | KW_TABLES:id
    {: RESULT = id; :}
    | KW_TEMPORARY:id
    {: RESULT = id; :}
    | KW_THAN:id
    {: RESULT = id; :}
    | KW_TIMESTAMP:id
    {: RESULT = id; :}
    | KW_TRANSACTION:id
    {: RESULT = id; :}
    | KW_TRIGGERS:id
    {: RESULT = id; :}
    | KW_TRUNCATE:id
    {: RESULT = id; :}
    | KW_TYPE:id
    {: RESULT = id; :}
    | KW_TYPES:id
    {: RESULT = id; :}
    | KW_UNCOMMITTED:id
    {: RESULT = id; :}
    | KW_USER:id
    {: RESULT = id; :}
    | KW_VARIABLES:id
    {: RESULT = id; :}
    | KW_VALUE:id
    {: RESULT = id; :}
    | KW_VERBOSE:id
    {: RESULT = id; :}
    | KW_VIEW:id
    {: RESULT = id; :}
    | KW_WARNINGS:id
    {: RESULT = id; :}
    | KW_WORK:id
    {: RESULT = id; :}
    | KW_CLUSTER:id
    {: RESULT = id; :}
    | KW_CLUSTERS:id
    {: RESULT = id; :}
    | KW_LINK:id
    {: RESULT = id; :}
    | KW_MIGRATE:id
    {: RESULT = id; :}
    | KW_MIGRATIONS:id
    {: RESULT = id; :}
    | KW_COUNT:id
    {: RESULT = id; :}
    | KW_SUM:id
    {: RESULT = id; :}
    | KW_MIN:id
    {: RESULT = id; :}
    | KW_MAX:id
    {: RESULT = id; :}
    | KW_FREE:id
    {: RESULT = id; :}
    | KW_TASK:id
    {: RESULT = id; :}
    | KW_ROUTINE:id
    {: RESULT = id; :}
    | KW_PAUSE:id
    {: RESULT = id; :}
    | KW_RESUME:id
    {: RESULT = id; :}
    | KW_STOP:id
    {: RESULT = id; :}
    | KW_GROUPING:id
    {: RESULT = id; :}
    | KW_DYNAMIC:id
    {: RESULT = id; :}
    | time_unit:id
    {: RESULT = id; :}
    | KW_ENABLE:id
    {: RESULT = id; :}
    | KW_FEATURE:id
    {: RESULT = id; :}
    ;

// Identifier that contain keyword
ident ::=
    IDENT:id
    {:
        RESULT = id;
    :}
    | keyword:id
    {:
        RESULT = id;
    :}
    ;


time_unit ::=
    KW_YEAR:id
    {: RESULT = id; :}
    | KW_MONTH:id
    {: RESULT = id; :}
    | KW_WEEK:id
    {: RESULT = id; :}
    | KW_DAY:id
    {: RESULT = id; :}
    | KW_HOUR:id
    {: RESULT = id; :}
    | KW_MINUTE:id
    {: RESULT = id; :}
    | KW_SECOND:id
    {: RESULT = id; :}
    ;

